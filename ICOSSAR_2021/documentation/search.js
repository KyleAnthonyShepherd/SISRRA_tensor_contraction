window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ICOSSAR_2021", "modulename": "ICOSSAR_2021", "qualname": "", "type": "module", "doc": "<p>This package contains the code I used to generate the ICOSSAR paper</p>\n\n<h6 id=\"author\">Author</h6>\n\n<p>Kyle Shepherd, at Rice University</p>\n\n<p>kas20@rice.edu</p>\n"}, {"fullname": "ICOSSAR_2021.ATRnumbaTrie", "modulename": "ICOSSAR_2021.ATRnumbaTrie", "qualname": "", "type": "module", "doc": "<p>This module calculates the all terminal reliability of undirected graphs</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p><strong>ATR(EdgeList,EP,verbose=False,TrieHashThreshold=10) :</strong> <br />\n    Calculates the All Terminal Reliability of a undirected graph defined by EdgeList.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When these functions are first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>Currently just for All Terminal Reliability. K-Terminal Reliability can be implemented in the future.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ATRnumbaTrie</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">k1</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"k\">for</span> <span class=\"n\">k2</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">k1</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">EdgeList</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">k1</span><span class=\"p\">,</span><span class=\"n\">k2</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EP</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">*</span><span class=\"mf\">.5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">REL</span><span class=\"p\">,</span><span class=\"n\">SetixTotal</span><span class=\"p\">,</span><span class=\"n\">SetixMax</span><span class=\"o\">=</span><span class=\"n\">ATR</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">EP</span><span class=\"p\">)</span>\n</code></pre></div>\n"}, {"fullname": "ICOSSAR_2021.ATRnumbaTrie.ATR", "modulename": "ICOSSAR_2021.ATRnumbaTrie", "qualname": "ATR", "type": "function", "doc": "<p>The numba optimized function that calculates all terminal reliability (ATR) for an undirected graph defined by a list of edges.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EdgeList</strong> (jx2 numpy array, int):\nEdgeList[i,0] and EdgeList[i,0] are the labels of the head node and tail node of edge i. j is the number of edges in the graph. Labels must be consecutive from 0 to n-1, where n is the number of nodes in the graph. The algorithm factors the graph from edge 0 to edge j. An optimized edge ordering should be fed into this function.</li>\n<li><strong>EP</strong> (1D numpy array of size n, float):\nEP[i] is the probability of edge i existing, probability of edge i not failing.</li>\n<li><strong>verbose</strong> (bool):\nControls verbosity to console when the function is called</li>\n<li><strong>TrieHashThreshold</strong> (int):\nIf the edge node set is equal to or exceeds this value, a hash table is used instead of a trie memory structure. The hash table is slower (due to collision checking), but takes up less memory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>FinalProb</strong> (float):\nThe all terminal reliability of the graph.</li>\n<li><strong>SetixTotal</strong> (int):\nTotal number of subgraphs considered in the algorithm</li>\n<li><strong>SetixMax</strong> (int):\nMaximum number of subgraphs considered in the algorithm at any one factoring step</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Currently just All Terminal Reliability. K-Terminal Reliability could be implemented.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">k1</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"k\">for</span> <span class=\"n\">k2</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">k1</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">EdgeList</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">k1</span><span class=\"p\">,</span><span class=\"n\">k2</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EP</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">*</span><span class=\"mf\">.5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">REL</span><span class=\"p\">,</span><span class=\"n\">SetixTotal</span><span class=\"p\">,</span><span class=\"n\">SetixMax</span><span class=\"o\">=</span><span class=\"n\">ATR</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">EP</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["EdgeList", "EP", "verbose", "TrieHashThreshold"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ContractionOrdering", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "", "type": "module", "doc": "<p>This module determines the best edge contraction order to use if a tree decomposition is given. The returned order optimizes for pathwidth</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p><strong>ContractionOrder(bags,tree) :</strong> <br />\n    Main function to determine the optimal contraction ordering from a tree decomposition.</p>\n\n<p><strong>GetOrder(r,bags,tree,MasterTree,SolvedOrder) :</strong> <br />\n    Recursive function for determining the optimal contraction ordering.</p>\n\n<p><strong>GetOrderSize(order,bags,tree,verbose=False) :</strong> <br />\n    Function for measuring the computational complexity of a given ordering.</p>\n\n<p><strong>GetNodeOrdering(order,bags,tree,verbose=False) :</strong> <br />\n    Function to convert a bag ordering into a node ordering.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Bag order is optimized using a greed local optimization recursive algorithm.</p>\n\n<p>Node contraction order within a bag is not optimized.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ContractionOrdering</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bags</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"go\">            [1, 2, 3],</span>\n<span class=\"go\">            [2, 4, 5],</span>\n<span class=\"go\">            [2, 3, 5],</span>\n<span class=\"go\">            [3, 5, 6]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"go\">            [0, 3],</span>\n<span class=\"go\">            [3],</span>\n<span class=\"go\">            [1, 2, 4],</span>\n<span class=\"go\">            [3]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">order</span><span class=\"p\">,</span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"n\">ContractionOrdering</span><span class=\"o\">.</span><span class=\"n\">ContractionOrder</span><span class=\"p\">(</span><span class=\"n\">bags</span><span class=\"p\">,</span><span class=\"n\">tree</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">NodeOrder</span><span class=\"p\">,</span><span class=\"n\">PathWidthSize</span><span class=\"o\">=</span><span class=\"n\">ContractionOrdering</span><span class=\"o\">.</span><span class=\"n\">GetNodeOrdering</span><span class=\"p\">(</span><span class=\"n\">order</span><span class=\"p\">,</span><span class=\"n\">bags</span><span class=\"p\">,</span><span class=\"n\">tree</span><span class=\"p\">,</span><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</code></pre></div>\n"}, {"fullname": "ICOSSAR_2021.ContractionOrdering.GetEdgeOrdering", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "GetEdgeOrdering", "type": "function", "doc": "<p></p>\n", "parameters": ["order", "bags", "tree", "G"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ContractionOrdering.GetNodeOrdering", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "GetNodeOrdering", "type": "function", "doc": "<p>Helper function to convert an optimized bag order into an optimized node contraction ordering.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>order</strong> (list, int):\nThe optimized bag contraction order.</li>\n<li><strong>bags</strong> (list of lists, int):\nTree decomposition algorithms output the tree bags in the format\nb 3 2 3 11 12 28 31 43 49\nwhere each number is a node label.\nbags[i] is the ith bag containing a list of the node labels in that bag.\nbags[i][j] is the jth node label in bag i.</li>\n<li><strong>tree</strong> (list of lists, int):\ntree[i] contains a list of the bags connected to bag i.</li>\n<li><strong>verbose</strong> (bool):\nboolean for verbose console output</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NodeOrder</strong> (list):\nA list of the optimized node contraction order</li>\n<li><strong>PathWidth</strong> (int):\nThe pathwidth of the given order.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>No attempt is made to optimize the node order within a given bag</p>\n", "parameters": ["order", "bags", "tree", "verbose"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ContractionOrdering.GetOrderSizeLineGraph", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "GetOrderSizeLineGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["order", "bags", "tree", "verbose"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ContractionOrdering.GetOrderSize", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "GetOrderSize", "type": "function", "doc": "<p>This function calculates the computational cost of a particular bag ordering.</p>\n\n<p>The node edge set, |EdgeSet|, the number of nodes in common between bags[0:n] and bags[n+1:B] is used to determine the complexity. B is the number of bags.</p>\n\n<p>Complexity is calculated by sum( BELL(|EdgeSet|) ) for n from 0 to B.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>order</strong> (list, int):\nThe bag contraction order to be measured</li>\n<li><strong>bags</strong> (list of lists, int):\nTree decomposition algorithms output the tree bags in the format\nb 3 2 3 11 12 28 31 43 49\nwhere each number is a node label.\nbags[i] is the ith bag containing a list of the node labels in that bag.\nbags[i][j] is the jth node label in bag i.</li>\n<li><strong>tree</strong> (list of lists, int):\nA deep copy of the whole bag tree.</li>\n<li><strong>verbose</strong> (bool):\nboolean for verbose console output</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>MaxVal</strong> (int):\nThe total computational complexity of the contraction ordering.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The computational worst case for a node edge set of size n is assumed, BELL(n).</p>\n", "parameters": ["order", "bags", "tree", "verbose"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ContractionOrdering.GetOrder", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "GetOrder", "type": "function", "doc": "<p>The main recursive function for optimizing the bag contraction order.</p>\n\n<p>For each possible branch contraction order, this function is recursively called.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (int):\nThe current bag subroot</li>\n<li><strong>bags</strong> (list of lists, int):\nTree decomposition algorithms output the tree bags in the format\nb 3 2 3 11 12 28 31 43 49\nwhere each number is a node label.\nbags[i] is the ith bag containing a list of the node labels in that bag.\nbags[i][j] is the jth node label in bag i.</li>\n<li><strong>tree</strong> (list of lists, int):\nThe subtree passed to the recursive function.\ntree[i] contains a list of the bags connected to bag i.</li>\n<li><strong>MasterTree</strong> (list of lists, int):\nA deep copy of the whole bag tree.</li>\n<li><strong>SolvedOrder</strong> (dict):\nSolvedOrder[o] stores the optimal branch contraction order for bag o.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>OptimumOrder</strong> (list):\nThe optimal contraction order for the branches and bags below bag r</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Only the local best contraction order is chosen for bag r.</p>\n", "parameters": ["r", "bags", "tree", "MasterTree", "SolvedOrder"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ContractionOrdering.ContractionOrder", "modulename": "ICOSSAR_2021.ContractionOrdering", "qualname": "ContractionOrder", "type": "function", "doc": "<p>Determines the optimum order to contract the bags in the tree decomposition. Specifically finds a contraction order to minimize Pathwidth.</p>\n\n<p>For each possible tree root, a greedy algorithm is used to optimize the bag contraction order. Starting at the root, the branch to contract first is recursively determined.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>bags</strong> (list of lists, int):\nTree decomposition algorithms output the tree bags in the format\nb 3 2 3 11 12 28 31 43 49\nwhere each number is a node label.\nbags[i] is the ith bag containing a list of the node labels in that bag.\nbags[i][j] is the jth node label in bag i.</li>\n<li><strong>tree</strong> (list of lists, int):\ntree[i] contains a list of the bags connected to bag i.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>order</strong> (list):\nThe optimal bag contraction order.</li>\n<li><strong>size</strong> (int):\nBELL(n). where n is the maximum size of the node edge set as the bags are contracted.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>As a greedy algorithm, the optimal solution, the optimal Pathwidth, is not guaranteed.</p>\n\n<p>The structure of the tree decomposition can affect the Pathwidth of the optimized order. Some grid graphs can have an optimal tree decomposition as measured by Treewidth, but the optimal Pathwidth cannot be extracted from the optimal tree decomposition.</p>\n\n<p>Only the bag contraction order is optimized. The contraction order of nodes within a bag is not optimized. For large bags, the order in which the nodes in the bag are contracted can affect the computational time of any algorithm that ingests the \"optimized\" order.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bags</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"go\">            [1, 2, 3],</span>\n<span class=\"go\">            [2, 4, 5],</span>\n<span class=\"go\">            [2, 3, 5],</span>\n<span class=\"go\">            [3, 5, 6]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"go\">            [0, 3],</span>\n<span class=\"go\">            [3],</span>\n<span class=\"go\">            [1, 2, 4],</span>\n<span class=\"go\">            [3]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">(</span><span class=\"n\">order</span><span class=\"p\">,</span><span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">ContractionOrder</span><span class=\"p\">(</span><span class=\"n\">bags</span><span class=\"p\">,</span><span class=\"n\">tree</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["bags", "tree"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "", "type": "module", "doc": "<p>This module contains functions to initiate the analysis for the ICOSSAR 2021 paper.</p>\n"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.MCtrials_vs_e", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "MCtrials_vs_e", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.GridRel_vs_n", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "GridRel_vs_n", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.GridRel_vs_n_MCtrials", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "GridRel_vs_n_MCtrials", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.GridRel_vs_len", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "GridRel_vs_len", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.GridRel_vs_len_MCtrials", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "GridRel_vs_len_MCtrials", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.InfRepeat", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "InfRepeat", "type": "function", "doc": "<p></p>\n", "parameters": ["filename"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.CubicGraphTreeWidths", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "CubicGraphTreeWidths", "type": "function", "doc": "<p></p>\n", "parameters": ["filename"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.RandomCubicFileRead", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "RandomCubicFileRead", "type": "function", "doc": "<p></p>\n", "parameters": ["filename", "edge_reliability"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.RandomCubicRelProcess", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "RandomCubicRelProcess", "type": "function", "doc": "<p></p>\n", "parameters": ["n"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.RandomCubicRel", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "RandomCubicRel", "type": "function", "doc": "<p></p>\n", "parameters": ["filename", "edge_reliability"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.RandomCubicRel_MCtrials", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "RandomCubicRel_MCtrials", "type": "function", "doc": "<p></p>\n", "parameters": ["filename"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.PowerGridsREL", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "PowerGridsREL", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.ICOSSAR_2021_analysis.PowerGridsREL_MCtrials", "modulename": "ICOSSAR_2021.ICOSSAR_2021_analysis", "qualname": "PowerGridsREL_MCtrials", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.cubic_graph_utilities", "modulename": "ICOSSAR_2021.cubic_graph_utilities", "qualname": "", "type": "module", "doc": "<p>This module contains functions to perform miscellaneous tasks on cubic graphs. Mostly for generating uniform connected random cubic graphs.</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p><strong>SetSeed(seed) :</strong>\n    Sets seed of numba runtime</p>\n\n<p><strong>ConnectedRandomCubicGenerate(pegs,G) :</strong>\n    numba optimized function for generating random uniform connected random cubic graphs. A 1-Flipper Markov Chain Monte Carlo (MCMC) algorithm is used to uniformly generate these random cubic graphs.\n    Algorithm from:\n    Tom\u00e1s Feder, Adam Guetz, Milena Mihail, and Amin Saberi. A local switch markov chain on given degree graphs with application in connectivity of peer-to-peer networks. In 2006 47th Annual IEEE Symposium on Foundations of Computer Science (FOCS\u201906), pages 69-76. IEEE, 2006\n    Code written by me.</p>\n\n<p><strong>ConnectedRandomCubic(n,EP=None) :</strong>\n    Returns a random uniform connected random cubic graph of size n by calling ConnectedRandomCubicGenerate</p>\n\n<p><strong>GenConnectedRandomCubic(ID0=0,ID1=10000,Vmin=20,Vmax=400,seed=42) :</strong>\n    Helper function to pre-generate a list of random connected cubic graphs.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the graph generation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n"}, {"fullname": "ICOSSAR_2021.cubic_graph_utilities.SetSeed", "modulename": "ICOSSAR_2021.cubic_graph_utilities", "qualname": "SetSeed", "type": "function", "doc": "<p>This function sets the seed of the numba runtime.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>seed</strong> (int):\nseeds the numba RNG</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">42</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">SetSeed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["seed"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.cubic_graph_utilities.ConnectedRandomCubicGenerate", "modulename": "ICOSSAR_2021.cubic_graph_utilities", "qualname": "ConnectedRandomCubicGenerate", "type": "function", "doc": "<p>This function generates random uniform connected cubic graphs. A 1-Flipper Markov Chain Monte Carlo (MCMC) algorithm is used to uniformly generate these random cubic graphs.\nAlgorithm from:\nTom\u00e1s Feder, Adam Guetz, Milena Mihail, and Amin Saberi. A local switch markov chain on given degree graphs with application in connectivity of peer-to-peer networks. In 2006 47th Annual IEEE Symposium on Foundations of Computer Science (FOCS\u201906), pages 69-76. IEEE, 2006\nCode written by me.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>pegs</strong> (1D numpy array of size n, int):\nArray containing the sequence of node degrees. Currently is overridden to only generate cubic graphs.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>G</strong> (nx(V+1) numpy array, int):\nThe randomly generated graph. G[n,0] is the (degree-1) of node n. G[n,1:degree+1] contains the labels of the nodes connected to node n by an edge</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>Currently just for cubic graphs. Graphs with arbitrary degree sequences can be implemented in the future.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">20</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pegs</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">int8</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">3</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">G</span><span class=\"o\">=</span><span class=\"n\">ConnectedRandomCubicGenerate</span><span class=\"p\">(</span><span class=\"n\">pegs</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["pegs"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.cubic_graph_utilities.ConnectedRandomCubic", "modulename": "ICOSSAR_2021.cubic_graph_utilities", "qualname": "ConnectedRandomCubic", "type": "function", "doc": "<p>This is the user called function that generates random uniform connected cubic graphs. It ingests the user desired graph size n, and creates the peg array, degree sequence array, to feed into the ConnectedRandomCubicGenerate function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n</strong> (int):\nsize of the desired random cubic graph. Must be even.</li>\n<li><strong>EP</strong> (float):\nThe probability of an edge not failing. This value is set if the user desires the output graph to be probabilistic, usually for reliability measurements.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ee</strong> (list of tuples):\nReturns the random cubic graph as an edge list.\nIf EP=None, each tuple contains two values (n1,n2). These are the labels of the nodes connected by that edge.\nif EP!=None, each tuple contains two values (n1,n2,EP). These are the labels of the nodes connected by that edge, and the probability of the edge not failing EP.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the graph generation by ConnectedRandomCubicGenerate is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">20</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"n\">ConnectedRandomCubic</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">20</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EP</span><span class=\"o\">=</span><span class=\"mf\">0.99</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"n\">ConnectedRandomCubic</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">EP</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["n", "EP"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.cubic_graph_utilities.GenConnectedRandomCubic", "modulename": "ICOSSAR_2021.cubic_graph_utilities", "qualname": "GenConnectedRandomCubic", "type": "function", "doc": "<p>Helper function to generate a file of pre-generated random cubic graphs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ID0</strong> (int):\nStart ID of generated graphs</li>\n<li><strong>ID1</strong> (int):\nEnd ID of generated graphs. ID1-ID0 graphs are generated.</li>\n<li><strong>Vmin</strong> (int):\nSmallest random cubic graph to generate, number of nodes.</li>\n<li><strong>Vmax</strong> (int):\nLargest random cubic graph to generate, number of nodes.</li>\n<li><strong>seed</strong> (int):\nseed for the random cubic graph generation process.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>file</strong> (list of tuples):\nCreates a file in the folder \"data\" named\n\"ConnectedRandomCubic-'+str(ID0)+'-'+str(ID1)+'-Vmin-'+str(Vmin)+'-Vmax-'+str(Vmax)+'-seed-'+str(seed)\"\n| delimated file.\nheader:\nGraph ID|Graph size in number of nodes|Edge List deliminated by ;</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Graph sizes between Vmin and Vmax inclusive are uniformly randomly selected.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID0</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID1</span><span class=\"o\">=</span><span class=\"mi\">10000</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Vmin</span><span class=\"o\">=</span><span class=\"mi\">20</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Vmax</span><span class=\"o\">=</span><span class=\"mi\">50</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">42</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">GenConnectedRandomCubic</span><span class=\"p\">(</span><span class=\"n\">ID0</span><span class=\"p\">,</span><span class=\"n\">ID1</span><span class=\"p\">,</span><span class=\"n\">Vmin</span><span class=\"p\">,</span><span class=\"n\">Vmax</span><span class=\"p\">,</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["ID0", "ID1", "Vmin", "Vmax", "seed"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.cubic_graph_utilities.CubicTreeWidthParallel", "modulename": "ICOSSAR_2021.cubic_graph_utilities", "qualname": "CubicTreeWidthParallel", "type": "function", "doc": "<p>function called by multiprocessing to calculate the Treewidth, Pathwidth, and LineGraphwidth of a graph.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n</strong> (tuple):\nn[0] contains the graph defined by an edgelist, list of tuples\nn[1] contains the ID of the graph from the random generation process, int\nn[2] contains the size of the graph in terms of the number of nodes, int</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>(n[1],n[2],TreeWidthSize,PathWidthSize,LineGraphWidth)</strong> (tuple):\n(Graph ID, Graph node count,Treewidth,Pathwidth,LineGraphwidth)</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Graph sizes between Vmin and Vmax inclusive are uniformly randomly selected.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[</span>  <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">.5</span><span class=\"p\">),</span>\n<span class=\"go\">                (0,2,.5),</span>\n<span class=\"go\">                (0,3,.5),</span>\n<span class=\"go\">                (1,2,.5),</span>\n<span class=\"go\">                (1,3,.5),</span>\n<span class=\"go\">                (2,3,.5)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">NodeCount</span><span class=\"o\">=</span><span class=\"mi\">4</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">ID</span><span class=\"p\">,</span><span class=\"n\">NodeCount</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">CubicTreeWidthParallel</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["n"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.general_utilities", "modulename": "ICOSSAR_2021.general_utilities", "qualname": "", "type": "module", "doc": "<p>This module contains functions to general utility tasks. The functions here are mostly responsible for converting from one graph format to another, and converting node labels from arbitrary strings to integers from 0 to |V|-1</p>\n"}, {"fullname": "ICOSSAR_2021.generate_figures", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "", "type": "module", "doc": "<p>This module contains functions to create the figures seen in the ICOSSAR 2021 paper.</p>\n"}, {"fullname": "ICOSSAR_2021.generate_figures.MCtrials_vs_e_Figure", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "MCtrials_vs_e_Figure", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.TensorGraphFigure", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "TensorGraphFigure", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.GridGraphComputeTimeFigure", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "GridGraphComputeTimeFigure", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.GridGraphComplexityFigure", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "GridGraphComplexityFigure", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.RandomCubicGraphFigure", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "RandomCubicGraphFigure", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.RandomCubicMonteCarlo", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "RandomCubicMonteCarlo", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.RandomCubicWidthFigure", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "RandomCubicWidthFigure", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.RandomCubicWidthFigure_short", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "RandomCubicWidthFigure_short", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.GridGraphnxnMonteCarlo", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "GridGraphnxnMonteCarlo", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.TreewidthCompare", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "TreewidthCompare", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.PowerGridMonteCarlo", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "PowerGridMonteCarlo", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.generate_figures.PowerGridTable", "modulename": "ICOSSAR_2021.generate_figures", "qualname": "PowerGridTable", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.reliability", "modulename": "ICOSSAR_2021.reliability", "qualname": "", "type": "module", "doc": "<p>This module calculates the reliability of undirected graphs.\nUsing tree decomposition algorithms, these functions optimize the edge factor ordering before the reliability calculations are performed.</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p><strong>ATR(EdgeList,ATRverbose=False,TreeWidthCalcTime=6) :</strong>\n    Calculates the All Terminal Reliability of a undirected graph defined by EdgeList.</p>\n\n<p><strong>EdgeCover(EdgeList,ECverbose=False,TreeWidthCalcTime=6) :</strong>\n    Calculates the Edge Cover of a undirected graph defined by EdgeList.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>The tree decomposition algorithms are written for UNIX operating environments, so windows environments must have the ability to run \"wsl.exe\" to properly execute these code packages.</p>\n\n<p>Currently just for All Terminal Reliability. K-Terminal Reliability can be implemented in the future.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">reliability</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">k1</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"k\">for</span> <span class=\"n\">k2</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">k1</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>        <span class=\"n\">EdgeList</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">k1</span><span class=\"p\">,</span><span class=\"n\">k2</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EP</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"o\">*</span><span class=\"mf\">.5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">REL</span><span class=\"p\">,</span><span class=\"n\">SetixTotal</span><span class=\"p\">,</span><span class=\"n\">SetixMax</span><span class=\"o\">=</span><span class=\"n\">reliability</span><span class=\"o\">.</span><span class=\"n\">ATR</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">EP</span><span class=\"p\">)</span>\n</code></pre></div>\n"}, {"fullname": "ICOSSAR_2021.reliability.ATR", "modulename": "ICOSSAR_2021.reliability", "qualname": "ATR", "type": "function", "doc": "<p>This function determines the All Terminal Reliability of a given graph. It calls the functions to optimize the edge contraction order, and calls the function to calculate the All Terminal Reliability.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EdgeList</strong> (list of tuples, (int,int,float)):\nEdgeList[i] is the ith edge of the graph.\nEdgeList[i][0] and EdgeList[i][1] are the node labels that the edge connects.\nEdgeList[i][2] is the probability of the edge not failing, the edge reliability.</li>\n<li><strong>ATRverbose</strong> (bool):\nbool controlling the amount of text output to the console</li>\n<li><strong>TreeWidthCalcTime</strong> (int):\nlength of time in seconds to compute the tree decomposition of the graph. First this length of time is used to attempt to exactly solve for a tree decomposition. If the solver does not finish in time, an approximate solver is used for this length of time.</li>\n<li><strong>ID</strong> (string):\nWhen this function is called in a parallel application, a unique ID should be passed so the tree decomposition programs do not overwrite each others output</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Result</strong> (dictionary):\nResult['REL']=All Terminal Reliability of the graph\nResult['CalculationEffort']=Total subgraphs computed\nResult['RELtime']=Wall clock computation time\nResult['TreeWidthSize']=Treewidth\nResult['PathWidthSize']=Pathwidth</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>Each run is not identical, the treewidth solvers use their own internal Pseudo-RNG and do not expose a way to set this seed. Therefore, while Result['REL'] should be the same each time, the computational effort may not be the same on each run.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[</span>  <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">.5</span><span class=\"p\">),</span>\n<span class=\"go\">                (0,2,.5),</span>\n<span class=\"go\">                (0,3,.5),</span>\n<span class=\"go\">                (1,2,.5),</span>\n<span class=\"go\">                (1,3,.5),</span>\n<span class=\"go\">                (2,3,.5)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">TreeWidthCalcTime</span><span class=\"o\">=</span><span class=\"mi\">60</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"s1\">&#39;64&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Results</span><span class=\"o\">=</span><span class=\"n\">ATR</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">TreeWidthCalcTime</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"n\">ID</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["EdgeList", "ATRverbose", "TreeWidthCalcTime", "ID"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.reliability.EdgeCover", "modulename": "ICOSSAR_2021.reliability", "qualname": "EdgeCover", "type": "function", "doc": "<p>This function determines the Edge Cover of a given graph, the probability the remaining edges cover all nodes in the graph. It calls the functions to optimize the edge contraction order, and calls the tensor network contraction function to calculate the Edge Cover.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EdgeList</strong> (list of tuples, (int,int,float)):\nEdgeList[i] is the ith edge of the graph.\nEdgeList[i][0] and EdgeList[i][1] are the node labels that the edge connects.\nEdgeList[i][2] is the probability of the edge not failing, the edge reliability.</li>\n<li><strong>ECverbose</strong> (bool):\nbool controlling the amount of text output to the console</li>\n<li><strong>TreeWidthCalcTime</strong> (int):\nlength of time in seconds to compute the tree decomposition of the graph. First this length of time is used to attempt to exactly solve for a tree decomposition. If the solver does not finish in time, an approximate solver is used for this length of time.</li>\n<li><strong>ID</strong> (string):\nWhen this function is called in a parallel application, a unique ID should be passed so the tree decomposition programs do not overwrite each others output</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Result</strong> (dictionary):\nResult['EC']=Edge Cover probability of the graph\nResult['CalculationEffort']=Total subgraphs computed\nResult['ECtime']=Wall clock computation time\nResult['LineGraphWidth']=Line Graph Treewidth</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>Each run is not identical, the treewidth solvers use their own internal Pseudo-RNG and do not expose a way to set this seed. Therefore, while Result['REL'] should be the same each time, the computational effort may not be the same on each run.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[</span>  <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">.5</span><span class=\"p\">),</span>\n<span class=\"go\">                (0,2,.5),</span>\n<span class=\"go\">                (0,3,.5),</span>\n<span class=\"go\">                (1,2,.5),</span>\n<span class=\"go\">                (1,3,.5),</span>\n<span class=\"go\">                (2,3,.5)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">TreeWidthCalcTime</span><span class=\"o\">=</span><span class=\"mi\">60</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"s1\">&#39;64&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Results</span><span class=\"o\">=</span><span class=\"n\">EdgeCover</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">TreeWidthCalcTime</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"n\">ID</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["EdgeList", "ECverbose", "TreeWidthCalcTime", "ID"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.script", "modulename": "ICOSSAR_2021.script", "qualname": "", "type": "module", "doc": "<p>This script executes all the code needed to generate the figures and tables in \"Tensor Network Contraction For Network Reliability Estimates\"</p>\n\n<p>Analysis and computation is performed by calling functions from ICOSSAR_2021_analysis.</p>\n\n<p>The plots are generated by calling functions from generate_figures</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This script takes ~24 hours to run.</p>\n\n<p>When some of these functions are first executed, numba performs jit compilation. This causes the first execution of that function to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">python</span> <span class=\"n\">script</span><span class=\"o\">.</span><span class=\"n\">py</span>\n</code></pre></div>\n"}, {"fullname": "ICOSSAR_2021.setup", "modulename": "ICOSSAR_2021.setup", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "ICOSSAR_2021.tensor_network_contraction", "modulename": "ICOSSAR_2021.tensor_network_contraction", "qualname": "", "type": "module", "doc": "<p>This module contains functions to perform miscellaneous tasks on cubic graphs. Mostly for generating uniform connected random cubic graphs.</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p><strong>Main(Nodes,EdgeOrder,pf=.5,verbose=True) :</strong> <br />\n    Main function called by user to calculate the tensor network contraction defined by the list of Nodes (tensors and their indices).</p>\n\n<p><strong>CoreLoop(T1,T1ix,T2,T2ix,Toutix) :</strong> <br />\n    Performs the tensor contraction.</p>\n\n<p><strong>CoreLoopScalar(T1,T1ix,T2,T2ix) :</strong> <br />\n    Performs the final tensor contraction down to a scalar.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the tensor network contraction is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>While the tensor network contraction for Source-Terminal reliability is discussed in the ICOSSAR 2021 paper and has an exact solution for directed acyclic networks, it is not implemented in this module.\nProof-of-concept code has been written to verify the S-T tensor construction.</p>\n"}, {"fullname": "ICOSSAR_2021.tensor_network_contraction.CoreLoop", "modulename": "ICOSSAR_2021.tensor_network_contraction", "qualname": "CoreLoop", "type": "function", "doc": "<p>This function performs the tensor product to contract, merge, two tensors.\nNumba complied for extra speed, much better at for loops then plain python or numpy.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>T1</strong> (1D numpy array of 2^(T1ix.shape), float):\nMulti dimensional tensor flattened to a vector.</li>\n<li><strong>T1ix</strong> (1D numpy array of size n, int):\nTensor indices for T1. T1 is addressed by:\nf(T1ix[0])<em>2^0+f(T1ix[1])</em>2^1+f(T1ix[2])<em>2^2+...+f(T1ix[n-1])</em>2^(n-1)\nwhere f is some function that returns the value of index k.</li>\n<li><strong>T2</strong> (1D numpy array of 2^(T2ix.shape), float):\nMulti dimensional tensor flattened to a vector.</li>\n<li><strong>T2ix</strong> (1D numpy array of size n, int):\nTensor indices for T2. T2 is addressed by:\nf(T2ix[0])<em>2^0+f(T2ix[1])</em>2^1+f(T2ix[2])<em>2^2+...+f(T2ix[n-1])</em>2^(n-1)\nwhere f is some function that returns the value of index k.</li>\n<li><strong>Toutix</strong> (1D numpy array of size n, int):\nTensor indices for Tout</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tout</strong> (1D numpy array of 2^(Toutix.shape), float):\nThe result of the tensor product</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T1</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T1ix</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T2</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"mi\">32</span><span class=\"p\">,</span><span class=\"mi\">64</span><span class=\"p\">,</span><span class=\"mi\">128</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T2ix</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Toutix</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Tout</span><span class=\"o\">=</span><span class=\"n\">CoreLoop</span><span class=\"p\">(</span><span class=\"n\">T1</span><span class=\"p\">,</span><span class=\"n\">T1ix</span><span class=\"p\">,</span><span class=\"n\">T2</span><span class=\"p\">,</span><span class=\"n\">T2ix</span><span class=\"p\">,</span><span class=\"n\">Toutix</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["T1", "T1ix", "T2", "T2ix", "Toutix"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.tensor_network_contraction.CoreLoopScalar", "modulename": "ICOSSAR_2021.tensor_network_contraction", "qualname": "CoreLoopScalar", "type": "function", "doc": "<p>This function performs the tensor product to contract, merge, two tensors.\nNumba complied for extra speed, much better at for loops then plain python or numpy. This function is used when the output is a scalar, no tensor indices needed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>T1</strong> (1D numpy array of 2^(T1ix.shape), float):\nMulti dimensional tensor flattened to a vector.</li>\n<li><strong>T1ix</strong> (1D numpy array of size n, int):\nTensor indices for T1. T1 is addressed by:\nf(T1ix[0])<em>2^0+f(T1ix[1])</em>2^1+f(T1ix[2])<em>2^2+...+f(T1ix[n-1])</em>2^(n-1)\nwhere f is some function that returns the value of index k.</li>\n<li><strong>T2</strong> (1D numpy array of 2^(T2ix.shape), float):\nMulti dimensional tensor flattened to a vector.</li>\n<li><strong>T2ix</strong> (1D numpy array of size n, int):\nTensor indices for T2. T2 is addressed by:\nf(T2ix[0])<em>2^0+f(T2ix[1])</em>2^1+f(T2ix[2])<em>2^2+...+f(T2ix[n-1])</em>2^(n-1)\nwhere f is some function that returns the value of index k.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tout</strong> (float):\nThe result of the tensor product</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T1</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T1ix</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T2</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"mi\">32</span><span class=\"p\">,</span><span class=\"mi\">64</span><span class=\"p\">,</span><span class=\"mi\">128</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T2ix</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Tout</span><span class=\"o\">=</span><span class=\"n\">CoreLoopScalar</span><span class=\"p\">(</span><span class=\"n\">T1</span><span class=\"p\">,</span><span class=\"n\">T1ix</span><span class=\"p\">,</span><span class=\"n\">T2</span><span class=\"p\">,</span><span class=\"n\">T2ix</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["T1", "T1ix", "T2", "T2ix"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.tensor_network_contraction.EdgeWeight", "modulename": "ICOSSAR_2021.tensor_network_contraction", "qualname": "EdgeWeight", "type": "function", "doc": "<p>This function contracts tensor T1 with a variable constraint tensor.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>T1</strong> (1D numpy array of 2^(T1ix.shape), float):\nMulti dimensional tensor flattened to a vector.</li>\n<li><strong>pf</strong> (float):\nprobability of the edge failing, edge unreliability</li>\n<li><strong>Eix</strong> (int):\nTensor index being contracted with the variable constraint tensor.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tout</strong> (float):\nThe result of the tensor product with the variable constraint tensor.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T1</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pf</span><span class=\"o\">=</span><span class=\"mf\">0.75</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Eix</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Tout</span><span class=\"o\">=</span><span class=\"n\">EdgeWeight</span><span class=\"p\">(</span><span class=\"n\">T1</span><span class=\"p\">,</span><span class=\"n\">pf</span><span class=\"p\">,</span><span class=\"n\">Eix</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["T1", "pf", "Eix"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.tensor_network_contraction.Main", "modulename": "ICOSSAR_2021.tensor_network_contraction", "qualname": "Main", "type": "function", "doc": "<p>This main function performs the tensor network contraction.\nThis outer loop is done in python, for ease of string, dictionary, list, and other mutable manipulation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>Nodes</strong> (list of tuples, (1D numpy array, (tuple of indices))):\nEach node is a tensor in the tensor network. Nodes[i][0] defines the ith tensor, and Nodes[i][1] defines the indices of this tensor. Each index aligns with an edge, a properly specified tensor network will have just two occurrences of an index.</li>\n<li><strong>EdgeOrder</strong> (list of tuples, int):\nA list of the edges in the order they should be contracted.</li>\n<li><strong>pf</strong> (float):\nA uniform edge probability. If len(EdgeOrder[i])=3, then the edge specifies its probability of existing, its reliability, and will override this global value.</li>\n<li><strong>verbose</strong> (bool):\nboolean to control how much text is displayed to the console</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tout</strong> (float):\nThe result of the tensor network contraction</li>\n<li><strong>CalculationEffort</strong> (int):\nThe number of floating point operations used to perform the entire calculation.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>When the reliability calculation is first executed, numba performs jit compilation. This causes the first execution to take several seconds to run, but the compilation is cached and future runs with different inputs do not need to recompile.</p>\n\n<p>Currently the code assumes the edge cover problem, and adds in the variable constraint tensors as needed. This code could be modified to be more general purpose.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">T</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">TT</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">**</span><span class=\"n\">k</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">TT</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">TT</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">],(</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],(</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],(</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],(</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Nodes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],(</span><span class=\"mi\">12</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">)))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeOrder</span><span class=\"o\">=</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">13</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Tout</span><span class=\"p\">,</span><span class=\"n\">CalculationEffort</span> <span class=\"o\">=</span> <span class=\"n\">Main</span><span class=\"p\">(</span><span class=\"n\">Nodes</span><span class=\"p\">,</span><span class=\"n\">EdgeOrder</span><span class=\"p\">,</span><span class=\"n\">pf</span><span class=\"o\">=</span><span class=\"mf\">.9</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["Nodes", "EdgeOrder", "pf", "verbose"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.tree_width", "modulename": "ICOSSAR_2021.tree_width", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "ICOSSAR_2021.tree_width.TreeWidth", "modulename": "ICOSSAR_2021.tree_width.TreeWidth", "qualname": "", "type": "module", "doc": "<p>This module contains functions to determine the tree decomposition of graphs.</p>\n\n<p>The exact treewidth solver is from here\nhttps://github.com/freetdi/p17</p>\n\n<p>The approximate treewidth solver is from here\nhttps://github.com/kit-algo/flow-cutter-pace17</p>\n\n<h6 id=\"functions\">Functions</h6>\n\n<p><strong>TreeWidthExact(EdgeList,seconds=6,ID='') :</strong> <br />\n    This function computes the minimum width tree decomposition of the graph. If it fails to find this minimum width tree decomposition, it falls back to the approximate solver.\n    https://github.com/freetdi/p17</p>\n\n<p><strong>TreeWidthApprox(EdgeList,seconds=6,ID='') :</strong> <br />\n    This function computes an approximate minimum width tree decomposition. When a termination signal is received, it outputs the best solution it found.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>These tree decomposition codes are only written to work on UNIX systems. To get it to work on windows systems, the command wsl.exe must be used.</p>\n\n<p>This can cause some strange and unstable behavior when doing parallel processes.</p>\n"}, {"fullname": "ICOSSAR_2021.tree_width.TreeWidth.TreeWidthApprox", "modulename": "ICOSSAR_2021.tree_width.TreeWidth", "qualname": "TreeWidthApprox", "type": "function", "doc": "<p>This function computes an approximate minimum width tree decomposition. When a termination signal is received, it outputs the best solution it found.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EdgeList</strong> (list of tuples, int):\nEdgelist[i][0] and Edgelist[i][1] are the node labels connected by edge i. Labels should be integers consecutive from 0 to |V|-1.</li>\n<li><strong>seconds</strong> (int):\nThe length of time to run the approximate treewidth solver.</li>\n<li><strong>ID</strong> (string):\nWhen doing parallel processing, a unique ID should be fed into this function to prevent different instances from overwriting each other on the same file</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>filename</strong> (string):\nThe name of the output file is returned, so the calling function can open the correct file.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The internal pseudo-rng is not easily accessible, so different runs may produce different tree decompositions.</p>\n\n<p>subprocess.Popen is used to call this function. It may be possible to hook these functions directly in python in the future, for better compatibility, portability, and stability</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[</span>  <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">.5</span><span class=\"p\">),</span>\n<span class=\"go\">                (0,2,.5),</span>\n<span class=\"go\">                (0,3,.5),</span>\n<span class=\"go\">                (1,2,.5),</span>\n<span class=\"go\">                (1,3,.5),</span>\n<span class=\"go\">                (2,3,.5)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">seconds</span> <span class=\"o\">=</span> <span class=\"mi\">15</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">filename</span> <span class=\"o\">=</span> <span class=\"n\">TreeWidthApprox</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">seconds</span><span class=\"o\">=</span><span class=\"n\">seconds</span><span class=\"p\">,</span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"n\">ID</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["EdgeList", "seconds", "ID"], "funcdef": "def"}, {"fullname": "ICOSSAR_2021.tree_width.TreeWidth.TreeWidthExact", "modulename": "ICOSSAR_2021.tree_width.TreeWidth", "qualname": "TreeWidthExact", "type": "function", "doc": "<p>This function computes an exact minimum width tree decomposition. When a termination signal is received, it does not return an ErrorCode equal to 0, so the approximate treewidth solver is called as a fallback.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EdgeList</strong> (list of tuples, int):\nEdgelist[i][0] and Edgelist[i][1] are the node labels connected by edge i. Labels should be integers consecutive from 0 to |V|-1.</li>\n<li><strong>seconds</strong> (int):\nThe length of time to run the approximate treewidth solver.</li>\n<li><strong>ID</strong> (string):\nWhen doing parallel processing, a unique ID should be fed into this function to prevent different instances from overwriting each other on the same file</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>filename</strong> (string):\nThe name of the output file is returned, so the calling function can open the correct file. This also lets the calling function know if the approximate solver fallback was used.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The internal pseudo-rng is not easily accessible, so different runs may produce different tree decompositions.</p>\n\n<p>subprocess.Popen is used to call this function. It may be possible to hook these functions directly in python in the future, for better compatibility, portability, and stability</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EdgeList</span><span class=\"o\">=</span><span class=\"p\">[</span>  <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">.5</span><span class=\"p\">),</span>\n<span class=\"go\">                (0,2,.5),</span>\n<span class=\"go\">                (0,3,.5),</span>\n<span class=\"go\">                (1,2,.5),</span>\n<span class=\"go\">                (1,3,.5),</span>\n<span class=\"go\">                (2,3,.5)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">seconds</span> <span class=\"o\">=</span> <span class=\"mi\">15</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">filename</span> <span class=\"o\">=</span> <span class=\"n\">TreeWidthExact</span><span class=\"p\">(</span><span class=\"n\">EdgeList</span><span class=\"p\">,</span><span class=\"n\">seconds</span><span class=\"o\">=</span><span class=\"n\">seconds</span><span class=\"p\">,</span><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"n\">ID</span><span class=\"p\">)</span>\n</code></pre></div>\n", "parameters": ["EdgeList", "seconds", "ID"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();